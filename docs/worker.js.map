{"version":3,"sources":["webpack://djfm-site-perso/./docs/filesToCache.js","webpack://djfm-site-perso/./src/client/worker.ts","webpack://djfm-site-perso/webpack/bootstrap","webpack://djfm-site-perso/webpack/startup"],"names":["module","exports","sw","self","cacheName","addEventListener","event","waitUntil","caches","open","then","cache","addAll","splice","length","request","url","URL","c","Clients","client","clientURL","host","respondWith","fetch","includes","pathname","endsWith","freshVersion","ok","put","match","cachedResp","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"mappings":"oCAAAA,EAAOC,QAAU,CACf,aACA,gBACA,iBACA,cACA,mBACA,wCACA,mDACA,kCACA,uCACA,sCACA,mBACA,gBACA,aACA,gBACA,mB,gSCfF,iBAMMC,EAAKC,KAGLC,EAAY,iBAIlBF,EAAGG,iBAAiB,WAAYC,IAE9BA,EAAMC,UAAUC,OAAOC,KAAKL,GAAWM,MACpCC,IACCA,EAAMC,OAAO,WAEb,UAAaC,OAAO,EAAG,UAAaC,eAO1CZ,EAAGG,iBAAiB,YAAY,SAQhCH,EAAGG,iBAAiB,SAAUC,IACEA,EAAMS,QAAQC,IAa5C,IAFA,I,EAAMA,EAAM,IAAIC,IAAIX,EAAMS,QAAQC,KAEzBE,EAAI,EAAGA,EAAIC,QAAQL,OAAQI,GAAK,EAAG,CAC1C,IAAME,EAASD,QAAQD,GACjBG,EAAY,IAAIJ,IAAIG,EAAOJ,KAEjC,GAAIA,EAAIM,OAASD,EAAUC,KAGzB,OAFsBN,EAAIM,UAC1BhB,EAAMiB,YAAYC,MAAMlB,EAAMS,UAKlCT,EAAMiB,a,EAAa,YAOjB,GAAI,UAAaE,SAAST,EAAIU,YACrBV,EAAIU,SAASC,SAAS,WACnB,UAAaF,SAAb,UAAyBT,EAAIU,SAA7B,iBACG,UAAaD,SAAb,UAAyBT,EAAIU,SAA7B,WAGb,CACI,WAAD,OACUV,EAAIU,SADd,4BAQH,IAAME,QAAqBJ,MACzBlB,EAAMS,SAGR,GAAIa,EAAaC,GAAI,CACf,2BAAD,OAA4Bb,EAAIU,SAAhC,uBACH,IAAMf,QAAcH,OAAOC,KAAKL,GAShC,aARMO,EAAMmB,IAAIxB,EAAMS,QAASa,GAI3B,aAAD,OACDZ,EAAIU,SADH,4DAGoBlB,OAAOuB,MAAMzB,EAAMS,SAK5C,aADyBP,OAAOuB,MAAMzB,EAAMS,WACvBa,EAUvB,IAAMI,QAAmBxB,OAAOuB,MAAMzB,EAAMS,SAC5C,OAAIiB,GAAcA,EAAWH,GACpBG,QAGcR,MAAMlB,EAAMS,U,uLClHnCkB,EAA2B,IAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAanC,QAGrB,IAAID,EAASiC,EAAyBE,GAAY,CAGjDlC,QAAS,IAOV,OAHAqC,EAAoBH,GAAUI,KAAKvC,EAAOC,QAASD,EAAQA,EAAOC,QAASiC,GAGpElC,EAAOC,QClBWiC,CAAoB,M","file":"worker.js","sourcesContent":["module.exports = [\n  '/bundle.js',\n  '/bundle.js.gz',\n  '/bundle.js.map',\n  '/index.html',\n  '/typescript.html',\n  '/typescript/jolis-exemples-en-ts.html',\n  '/typescript/rapidement-configurer-un-projet.html',\n  '/typescript/type-narrowing.html',\n  '/typescript/types-vs-interfaces.html',\n  '/typescript/typescript-en-bref.html',\n  '/filesToCache.js',\n  '/style.js.map',\n  '/worker.js',\n  '/worker.js.gz',\n  '/worker.js.map',\n];\n","import filesToCache from '../../docs/filesToCache';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst log = (...args: unknown[]) => null;\n\n// eslint-disable-next-line no-restricted-globals\nconst sw = self as unknown as ServiceWorkerGlobalScope & typeof globalThis;\n\n// Choose a cache name\nconst cacheName = 'djfm.github.io';\n\n// When the service worker is installing,\n// open the cache and add the pre-cache resources to it\nsw.addEventListener('install', (event) => {\n  log('####::::  installing ServiceWorker with', { cacheName });\n  event.waitUntil(caches.open(cacheName).then(\n    (cache) => {\n      cache.addAll(filesToCache);\n      // we do not need to cache them any longer\n      filesToCache.splice(0, filesToCache.length);\n      // TODO find a way to not over-cache them\n      // in subsequent requests?\n    },\n  ));\n});\n\nsw.addEventListener('activate', () => {\n  log('Service worker activate event!');\n  log('Environment is', process.env.NODE_ENV);\n});\n\n// When there's an incoming fetch request,\n// try and respond with a pre-cached resource,\n// otherwise fall back to the network\nsw.addEventListener('fetch', (event: FetchEvent) => {\n  log('Fetch intercepted for:', event.request.url);\n\n  if (process.env.NODE_ENV === 'development') {\n    log(\n      'Not using the cache since env is set to \"development\".',\n      'ServiceWorker bails.',\n    );\n    event.respondWith(fetch(event.request));\n    return;\n  }\n\n  const url = new URL(event.request.url);\n\n  for (let c = 0; c < Clients.length; c += 1) {\n    const client = Clients[c];\n    const clientURL = new URL(client.url);\n    // don't bother about external resources\n    if (url.host !== clientURL.host) {\n      log('Ignoring host:', url.host);\n      event.respondWith(fetch(event.request));\n      return;\n    }\n  }\n\n  event.respondWith((async (): Promise<Response> => {\n    /**\n     * If a public file has changed, we try to fetch it\n     * from the network, and then store it in the cache.\n     *\n     * If it fails, we fall back to the cache later.\n     */\n    if (filesToCache.includes(url.pathname)\n        || (!url.pathname.endsWith('.html')\n            && (filesToCache.includes(`${url.pathname}/index.html`)\n                || filesToCache.includes(`${url.pathname}.html`)\n            )\n        )\n    ) {\n      log(\n        `File at ${url.pathname} has supposedly changed:`,\n        'trying to fetch it from the network',\n        'and to add it to the cache afterwards.',\n        'If we cannot get it from the network,',\n        'we will try to get it from the cache.',\n      );\n\n      const freshVersion = await fetch(\n        event.request,\n      );\n\n      if (freshVersion.ok) {\n        log(`Got an OK response for \"${url.pathname}\" from the network.`);\n        const cache = await caches.open(cacheName);\n        await cache.put(event.request, freshVersion);\n        // Apparently there is an issue if I return a response\n        // that I have put in the cache, so I need to put it then\n        // to retrieve it immediately after.\n        log(`Returning ${\n          url.pathname\n        } from the cache right after having added it to it.`);\n        const response = await caches.match(event.request);\n        return response;\n      }\n\n      const cachedResp = await caches.match(event.request);\n      return cachedResp || freshVersion;\n    }\n\n    /**\n     * If we were requested a resource that\n     * we do not need to refresh, then\n     * return it from the cache if it is\n     * available, and from the network otherwise.\n     */\n\n    const cachedResp = await caches.match(event.request);\n    if (cachedResp && cachedResp.ok) {\n      return cachedResp;\n    }\n\n    const response = await fetch(event.request);\n    return response;\n  })());\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(1551);\n"],"sourceRoot":""}